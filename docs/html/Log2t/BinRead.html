<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Log2t::BinRead - support for reading binary log file in Log2timeline</title>
<link rel="stylesheet" href="./docs/html/default.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:kiddi@dhcp-172-19-33-45.mtv.corp.google.com" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>Log2t::BinRead - support for reading binary log file in Log2timeline</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="set_endian" class="item">set_endian ( TYPE )</a></strong></dt>

<dd>
<p>This method sets the endian of the binary file.  By default values are returned as if the coding was done in a little endian systems, but that can be changed.  The types are:</p>
<ul>
<li><strong><a name="0_big_e" class="item">0 BIG_E</a></strong>

<p>Represents a big endian ending</p>
</li>
<li><strong><a name="1_little_e" class="item">1 LITTLE_E</a></strong>

<p>Represents a little endian ending (the default settings)</p>
</li>
</ul>
</dd>
<dt><strong><a name="read_ascii" class="item">read_ascii ( \*FH, \$ofs, $length )</a></strong></dt>

<dd>
<p>This function returns an ASCII string of length $length read from the binary file FH (accepts FH as a reference to a typeglob of the filehandle).
The variable offset dictates where in the binary file we find the start of the string, the offset variable is a reference, since the offset variable is increased
as each character is read (so the offset variable will be $ofs+$length at the end of the function)</p>
</dd>
<dt><strong><a name="read_ascii_end" class="item">read_ascii_end ( \*FH, \$ofs, $max )</a></strong></dt>

<dd>
<p>This function returns an ASCII string of maximum length $length, from the binary file FH (accepts FH as a reference to a typeglob of the filehandle), but otherwise until an \0 or a null character is seen. The variable offset dictates where in the binary file we find the start of the string, the offset variable is a reference, since the offset variable is increased as each character is read (the offset variable will be set at the end of the string)</p>
</dd>
<dt><strong><a name="read_unicode" class="item">read_unicode ( \*FH, \$ofs, $length )</a></strong></dt>

<dd>
<p>This function returns an Unicode encoded string of length $length read from the binary file FH (accepts FH as a reference to a typeglob of the filehandle).
The variable offset dictates where in the binary file we find the start of the string, the offset variable is a reference, since the offset variable is increased
as each character is read (so the offset variable will be $ofs+($length*2) at the end of the function)</p>
</dd>
<dt><strong><a name="read_unicode_end" class="item">read_unicode_end ( \*FH, \$ofs, $max )</a></strong></dt>

<dd>
<p>This function returns an Unicode encoded string of maximum length $length from the binary file FH (accepts FH as a reference to a typeglob of the filehandle), but otherwise until an \00 or a null character is seen. The variable offset dictates where in the binary file we find the start of the string, the offset variable is a reference, since the offset variable is increased as each character is read (the offset variable will be set at the end of the string)</p>
</dd>
<dt><strong><a name="read_4" class="item">read_4 ( \*FH, \$ofs, $loc )</a></strong></dt>

<dd>
<p>This function reads four bits or a nibble (half a byte) from the file FH (accepts FH as a reference to a typeglob of the filehandle) and return it. The offset is increased by one byte even though the operation returns only a nibble.</p>
<p>The variable $loc defines whether the higher or lower nibble is returned (one byte is read, which is then divided accordingly). Accepted values are:</p>
<ul>
<li><strong><a name="0_the_lower_four_bits_are_returned" class="item">0 The lower four bits are returned</a></strong>

</li>
<li><strong><a name="1_the_upper_four_bits_are_returned" class="item">1 The upper four bits are returned</a></strong>

</li>
</ul>
</dd>
<dt><strong><a name="read_8" class="item">read_8 ( \*FH, \$ofs )</a></strong></dt>

<dd>
<p>This function reads 8 bits or one byte from the file FH (accepts FH as a reference to a typeglob of the filehandle) and return it according to the set endian of the file (default is little endian).  The offset is then increased by one.</p>
</dd>
<dt><strong><a name="read_16" class="item">read_16 ( \*FH, \$ofs )</a></strong></dt>

<dd>
<p>This function reads 16 bits or two bytes from the file FH (accepts FH as a reference to a typeglob of the filehandle) and return it according to the set endian of the file (default is little endian).  The offset is then increased by two.</p>
</dd>
<dt><strong><a name="read_32" class="item">read_32 ( \*FH, \$ofs )</a></strong></dt>

<dd>
<p>This function reads 32 bits or four bytes from the file FH (accepts FH as a reference to a typeglob of the filehandle) and return it according to the set endian of the file (default is little endian).  The offset is then increased by four.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Kristinn Gudjonsson &lt;kristinn (a t) log2timeline ( d o t ) net&gt; is the original author of the program.</p>
<p>The tool is released under GPL so anyone can contribute to the tool.  Some parts of the code have been copied from other GPL'ed programs, such as RegRipper written by H. Carvey.</p>

</body>

</html>
